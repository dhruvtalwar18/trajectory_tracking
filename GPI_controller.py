# -*- coding: utf-8 -*-
"""PR3_part_2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Bud330uCHpzwJpC7Pc-p18otb-ZbpEdl
"""

!pip install sparse

import numpy as np
from scipy.stats import multivariate_normal
from tqdm import tqdm
from scipy.sparse import coo_matrix as COO
import pickle
import itertools as it
from sparse import COO
import pickle
import numpy as np
from tqdm import tqdm
import pickle
import itertools as it
from scipy.stats import multivariate_normal
from tqdm import tqdm
from scipy.sparse import coo_matrix
import pickle

import numpy as np
from numpy import sin, cos, pi
import matplotlib.pyplot as plt
from matplotlib import animation
from time import time


def visualize(car_states, ref_traj, obstacles, t, time_step, save=False):
    init_state = car_states[0,:]
    def create_triangle(state=[0,0,0], h=0.5, w=0.25, update=False):
        x, y, th = state
        triangle = np.array([
            [h, 0   ],
            [0,  w/2],
            [0, -w/2],
            [h, 0   ]
        ]).T
        rotation_matrix = np.array([
            [cos(th), -sin(th)],
            [sin(th),  cos(th)]
        ])

        coords = np.array([[x, y]]) + (rotation_matrix @ triangle).T
        if update == True:
            return coords
        else:
            return coords[:3, :]

    def init():
        return path, current_state, target_state,

    def animate(i):
        # get variables
        x = car_states[i,0]
        y = car_states[i,1]
        th = car_states[i,2]

        # update path
        if i == 0:
            path.set_data(np.array([]), np.array([]))
        x_new = np.hstack((path.get_xdata(), x))
        y_new = np.hstack((path.get_ydata(), y))
        path.set_data(x_new, y_new)

        # update horizon
        #x_new = car_states[0, :, i]
        #y_new = car_states[1, :, i]
        #horizon.set_data(x_new, y_new)

        # update current_state
        current_state.set_xy(create_triangle([x, y, th], update=True))

        # update current_target
        x_ref = ref_traj[i,0]
        y_ref = ref_traj[i,1]
        th_ref = ref_traj[i,2]
        target_state.set_xy(create_triangle([x_ref, y_ref, th_ref], update=True))

        # update target_state
        # xy = target_state.get_xy()
        # target_state.set_xy(xy)

        return path, current_state, target_state,
    circles = []
    for obs in obstacles:
        circles.append(plt.Circle((obs[0], obs[1]), obs[2], color='r', alpha = 0.5))
    # create figure and axes
    fig, ax = plt.subplots(figsize=(6, 6))
    min_scale_x = min(init_state[0], np.min(ref_traj[:,0])) - 1.5
    max_scale_x = max(init_state[0], np.max(ref_traj[:,0])) + 1.5
    min_scale_y = min(init_state[1], np.min(ref_traj[:,1])) - 1.5
    max_scale_y = max(init_state[1], np.max(ref_traj[:,1])) + 1.5
    ax.set_xlim(left = min_scale_x, right = max_scale_x)
    ax.set_ylim(bottom = min_scale_y, top = max_scale_y)
    for circle in circles:
        ax.add_patch(circle)
    # create lines:
    #   path
    path, = ax.plot([], [], 'k', linewidth=2)

    #   current_state
    current_triangle = create_triangle(init_state[:3])
    current_state = ax.fill(current_triangle[:, 0], current_triangle[:, 1], color='r')
    current_state = current_state[0]
    #   target_state
    target_triangle = create_triangle(ref_traj[0,0:3])
    target_state = ax.fill(target_triangle[:, 0], target_triangle[:, 1], color='b')
    target_state = target_state[0]

    #   reference trajectory
    ax.scatter(ref_traj[:,0], ref_traj[:,1], marker='x')

    sim = animation.FuncAnimation(
        fig=fig,
        func=animate,
        init_func=init,
        frames=len(t),
        interval=time_step*100,
        blit=True,
        repeat=True
    )
    plt.show()

    if save == True:
        sim.save('./fig/animation' + str(time()) +'.gif', writer='ffmpeg', fps=15)

    return

def generate_state_and_control_space():
    '''
    Function to create the state and control space of the tracking problem
    The state space contains time, error_x, error_y, and error_th
    The control space includes the linear velocity and the angular velocity of the robot
    '''
    t = np.arange(0, 51, 0.5)[:-1]
    error_x = [-3, -0.5] + list(np.linspace(-0.25, 0.25, 5)) + [0.5, 3]
    error_y = error_x
    error_th = [-np.pi, -np.pi/2] + list(np.linspace(-np.pi/4, np.pi/4, 5)) + [np.pi/2, np.pi]

    state_space = list(it.product(t, error_x, error_y, error_th))
    state_table = {state: i for i, state in enumerate(state_space)}

    linear_velocities = np.linspace(0, 1, 10)
    angular_velocities = np.linspace(-1, 1, 10)

    control_space = list(it.product(linear_velocities, angular_velocities))

    return state_space, error_x, error_y, error_th, control_space, state_table

state_space, error_x, error_y, error_th, control_space, state_table = generate_state_and_control_space()
state_n = len(state_space)
control_n = len(control_space)
L = np.zeros((state_n, control_n))

time_step = 0.5
def lissajous(k):
    xref_start = 0
    yref_start = 0
    A = 2
    B = 2
    a = 2 * np.pi / 50
    b = 3 * a
    T = np.round(2 * np.pi / (a * time_step))
    k = k % T
    delta = np.pi / 2
    xref = xref_start + A * np.sin(a * k * time_step + delta)
    yref = yref_start + B * np.sin(b * k * time_step)
    v = [A * a * np.cos(a * k * time_step + delta), B * b * np.cos(b * k * time_step)]
    thetaref = np.arctan2(v[1], v[0])
    return [xref, yref, thetaref]
traj = lissajous
cur_ref = [traj(i) for i in range(200)]

def calculate_next_error(error, control, reference_diff):
    G = np.array([[0.5 * np.cos(error[2] + reference_diff[2]), 0], [0.5 * np.sin(error[2] + reference_diff[2]), 0], [0, 0.5]])
    next_error = error[:, None] + G @ np.array([[control[0]], [control[1]]]) + reference_diff
    next_error[2] = (next_error[2] + np.pi) % (2 * np.pi) - np.pi
    next_x, next_y, next_th = next_error[0][0], next_error[1][0], next_error[2][0]
    return next_x, next_y, next_th

def error_(error, control, time, ref):
    ref_diff = np.array([[ref[time][0] - ref[time+1][0]], [ref[time][1] - ref[time+1][1]], [ref[time][2] -  ref[time+1][2]]])
    next_x, next_y, next_th = calculate_next_error(error, control, ref_diff)
    k = 4
    ind_x = np.abs(next_x - error_x).argsort()[:k]
    ind_y = np.abs(next_y - error_y).argsort()[:k]
    ind_th = np.abs(next_th - error_th).argsort()[:k]
    next_states, prob_ = [], []
    mean = [next_x, next_y, next_th]
    pdf = multivariate_normal(mean=mean, cov=np.diag([0.04, 0.04, 0.004]))
    for i in range(k):
        next_states.append(state_table[(0.5*(time + 1) % 50, error_x[ind_x[i]], error_y[ind_y[i]], error_th[ind_th[i]])])
        prob_.append(pdf.pdf([(error_x[ind_x[i]]), (error_y[ind_y[i]]), (error_th[ind_th[i]])]))
    prob_ = np.array(prob_)
    prob_ /= np.sum(prob_)
    return next_states, prob_


coords = []
data = []

for i in tqdm(range(state_n)):
    e = np.array(state_space[i][1:])
    t = int(state_space[i][0] // 0.5)
    for j in range(control_n):
        next_states, probb = error_(e, control_space[j], t, cur_ref)
        for k in range(len(next_states)):
            coords.append((i, j, next_states[k]))
            data.append(probb[k])

coords = np.array(coords).T
data = np.array(data)
shape = (state_n, control_n, state_n)
p = coo_matrix((data, (coords[0], coords[1], coords[2])), shape=shape)

np.save('P_ij_matrix.npy', p)

import numpy as np

# Load matrix data from .npy file
P_ = np.load('/content/drive/MyDrive/P_ij_matrix.npy')

Q = 50
q = 20
R = 2

def check_collision(x, y):
    x_c = np.array([-2, 1])
    y_c = np.array([-2, 2])
    w_x, w_y = 0, 0
    k = 25
    dist_sq = (x + w_x - x_c)**2 + (y + w_y - y_c)**2
    collision = np.sum(dist_sq < 0.50**2)
    penalty = k * collision
    return penalty


def stage_cost(error, controll, time, ref=cur_ref):
  """
  Function to calculate the cost of taking a step in the MDP.

  Args:
    e: The current state of the system.
    u: The control input.
    t: The current time step.
    ref: The reference trajectory.

  Returns:
    The cost of taking a step.
  """

  # Define the cost matrices.
  Q_p = Q * np.eye(2)
  R_p = R * np.eye(2)

  # Calculate the position and orientation of the robot.
  position_e = error[:2]
  angle_e = error[-1]

  # Calculate the control input.
  u = np.array([[controll[0]], [controll[1]]])

  # Calculate the penalty for collision.
  penalty = check_collision(position_e[0] + ref[time][0], position_e[1] + ref[time][1])

  # Calculate the cost of taking a step.
  cost = position_e.T @ Q_p @ position_e + q * (1 - np.cos(angle_e)) ** 2 + u.T @ R_p @ u + penalty

  return cost


def create_L(i):
  """
  Function to create the cost-to-go matrix for the MDP.

  Args:
    i: The current state index.

  Returns:
    The cost-to-go vector for the current state.
  """

  # Calculate the cost-to-go vector for the current state.
  l = np.zeros(control_n)
  for j in range(control_n):
    l[j] = stage_cost(np.array(state_space[i][1:]), control_space[j], int(state_space[i][0] // 0.5))

  return l

for i in tqdm(range(state_n)):
  L[i] = create_L(i)






def value_iteration_matrix(V, L, p):
  """
  Function to perform value iteration on the MDP.

  Args:
    V: The value function.
    L: The cost-to-go matrix.
    p: The transition matrix.
    thresh: The convergence threshold.

  Returns:
    The optimal policy.
  """

  count = 0
  gamma = 0.99
  while True:
    Q = L + gamma * (p @ V[:, None])[:, :, -1]
    V_new = np.min(Q, axis=1)
    pi = np.argmin(Q, axis=1)
    if np.linalg.norm(V_new - V, np.inf) <= 0.000001:
      return pi
    count += 1
    if count == 700:
      return pi
    V = V_new



n_states = P_.shape[0]
num_iters = 5000
n_controlspace = P_.shape[1]
V = np.zeros((num_iters + 1, n_states))

pi = value_iteration_matrix(V, L, P_)

filename = 'policy50202.npy'
np.save(filename, [pi, state_space, error_x, error_y, error_th, state_table, control_space])

from time import time
import numpy as np

# Simulation params
np.random.seed(10)
time_step = 0.5 # time between steps in seconds
sim_time = 120    # simulation time

# Car params
x_init = 1.5
y_init = 0.0
theta_init = np.pi/2
v_max = 1
v_min = 0
w_max = 1
w_min = -1

# This function returns the reference point at time step k
def lissajous(k):
    xref_start = 0
    yref_start = 0
    A = 2
    B = 2
    a = 2*np.pi/50
    b = 3*a
    T = np.round(2*np.pi/(a*time_step))
    k = k % T
    delta = np.pi/2
    xref = xref_start + A*np.sin(a*k*time_step + delta)
    yref = yref_start + B*np.sin(b*k*time_step)
    v = [A*a*np.cos(a*k*time_step + delta), B*b*np.cos(b*k*time_step)]
    thetaref = np.arctan2(v[1], v[0])
    return [xref, yref, thetaref]

# This function implements a simple P controller
def simple_controller(cur_state, ref_state):
    k_v = 0.55
    k_w = 1.0
    v = k_v*np.sqrt((cur_state[0] - ref_state[0])**2 + (cur_state[1] - ref_state[1])**2)
    v = np.clip(v, v_min, v_max)
    angle_diff = ref_state[2] - cur_state[2]
    angle_diff = (angle_diff + np.pi) % (2 * np.pi ) - np.pi
    w = k_w*angle_diff
    w = np.clip(w, w_min, w_max)
    return [v,w]

# This function implement the car dynamics
def car_next_state(time_step, cur_state, control, noise = True):
    theta = cur_state[2]
    rot_3d_z = np.array([[np.cos(theta), 0], [np.sin(theta), 0], [0, 1]])
    f = rot_3d_z @ control
    mu, sigma = 0, 0.04 # mean and standard deviation for (x,y)
    w_xy = np.random.normal(mu, sigma, 2)
    mu, sigma = 0, 0.004  # mean and standard deviation for theta
    w_theta = np.random.normal(mu, sigma, 1)
    w = np.concatenate((w_xy, w_theta))
    if noise:
        return cur_state + time_step*f.flatten() + w
    else:
        return cur_state + time_step*f.flatten()

if __name__ == '__main__':
    # Obstacles in the environment
    obstacles = np.array([[-2,-2,0.5], [1,2,0.5]])
    # Params
    traj = lissajous
    ref_traj = []
    error_total = 0.0
    car_states = []
    times = []

    main_loop = time()
    # Initialize state
    cur_state = np.array([x_init, y_init, theta_init])
    cur_iter = 0
    ####################################################################
    Q,q,R = 50, 20, 2
    ######################################################################
    filename = '/content/policy50202.npy'

    results = np.load(filename, allow_pickle=True)
    pi, state_space, error_x, error_y, error_th, state_table, control_space = results[0], results[1], results[2], results[3], results[4], results[5], results[6]
    # pi, state_space, error_x, error_y, error_th, state_table, control_space = results


    while (cur_iter * time_step < sim_time):
        t1 = time()
        # Get reference state
        cur_time = cur_iter*time_step
        # cur_ref = traj(cur_iter)
        cur_ref = []
        for i in range(120):
            cur_ref.append(traj(cur_iter + i))
        # Save current state and reference state for visualization
        ref_traj.append(cur_ref[0])
        car_states.append(cur_state)
        error = 1*(cur_state - cur_ref[0])
        error[2] = (error[2] + np.pi) % (2 * np.pi) - np.pi
        errorr_x = error_x[np.argmin(np.abs(error[0] - error_x))]
        errorr_y = error_y[np.argmin(np.abs(error[1] - error_y))]
        errorr_th = error_th[np.argmin(np.abs(error[2] - error_th ))]
        index = state_table[((cur_iter*time_step) %50, errorr_x, errorr_y, errorr_th)]

        ################################################################
        # Generate control input
        # TODO: Replace this simple controller with your own controller
        # control = simple_controller(cur_state, cur_ref[0])
        control = control_space[pi[index]]
        v = control[0]
        w = control[1]
        v = np.clip(v, v_min, v_max)
        w = np.clip(w,w_min, w_max)
        ################################################################

        # Apply control input
        next_state = car_next_state(time_step, cur_state, [v,w], noise=True)
        # Update current state
        cur_state = next_state
        # Loop time
        t2 = time()

        times.append(t2-t1)
        error_total= error_total + np.linalg.norm([cur_state[0] - cur_ref[1][0], cur_state[1] - cur_ref[1][1],
        (cur_state[2] - cur_ref[1][2] + np.pi) % (2*np.pi) - np.pi])
        cur_iter = cur_iter + 1

    main_loop_time = time()
    print('\n\n')
    print('Total time: ', main_loop_time - main_loop)
    print('Average iteration time: ', np.array(times).mean() * 1000, 'ms')
    print('Final error: ', error_total)



    # Visualization
    ref_traj = np.array(ref_traj)
    car_states = np.array(car_states)
    times = np.array(times)
    visualize(car_states, ref_traj, obstacles, times, time_step,save=True)